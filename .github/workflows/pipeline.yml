name: Pipeline Run

on:
  # schedule:
  #   - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      stage:
        description: 'Run specific stage (sync, pdf, grobid, extract, enrich, flora, author, email) or all'
        default: 'all'
      limit:
        description: 'Max items per stage (0 = unlimited)'
        default: '0'
      email_limit:
        description: 'Max emails (recipients) to send per run (0 = skip email)'
        default: '0'
      download_workers:
        description: 'Parallel workers for PDF downloads'
        default: '4'
      enrich_workers:
        description: 'Parallel workers for Crossref/OpenAlex enrichment'
        default: '6'
      orcid_workers:
        description: 'Parallel workers for ORCID lookups'
        default: '3'
      backlog_depth:
        description: 'How many follow-up runs remain (0 = no re-trigger)'
        default: '5'

jobs:
  pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 330

    services:
      grobid:
        image: grobid/grobid:0.8.2.1-full
        ports:
          - 8070:8070
        options: >-
          --health-cmd "curl -f http://localhost:8070/api/isalive || exit 1"
          --health-interval 15s
          --health-timeout 10s
          --health-retries 20

    env:
      GROBID_URL: http://localhost:8070
      PDF_DEST_ROOT: /tmp/preprints
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      OPENALEX_EMAIL: ${{ secrets.OPENALEX_EMAIL }}
      OSF_API_TOKEN: ${{ secrets.OSF_API_TOKEN }}
      ORCID_CLIENT_ID: ${{ secrets.ORCID_CLIENT_ID }}
      ORCID_CLIENT_SECRET: ${{ secrets.ORCID_CLIENT_SECRET }}
      CROSSREF_MAILTO: ${{ secrets.CROSSREF_MAILTO }}
      OPENALEX_MAILTO: ${{ secrets.OPENALEX_MAILTO }}
      TEI_S3_BUCKET: flora-preprint-tei-cache
      GMAIL_SENDER_ADDRESS: flora@replications.forrt.org
      GMAIL_APP_PASSWORD: ${{ secrets.GMAIL_APP_PASSWORD }}
      PIPELINE_NOTIFY_EMAIL: ${{ secrets.PIPELINE_NOTIFY_EMAIL }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends libreoffice-core

      - name: Install Python dependencies
        run: pip install -r requirements.txt

      - name: Run pipeline
        id: run
        run: |
          STAGE="${{ inputs.stage || 'all' }}"
          LIMIT="${{ inputs.limit || '0' }}"
          DL_WORKERS="${{ inputs.download_workers || '4' }}"
          ENRICH_WORKERS="${{ inputs.enrich_workers || '6' }}"
          ORCID_WORKERS="${{ inputs.orcid_workers || '3' }}"

          # Convert limit 0 to a large number (effectively unlimited)
          if [ "$LIMIT" = "0" ]; then
            LIMIT="100000"
          fi

          EMAIL_LIMIT="${{ inputs.email_limit || '20' }}"

          EMAIL_ARGS=""
          if [ "$EMAIL_LIMIT" != "0" ]; then
            EMAIL_ARGS="--include-email --email-limit $EMAIL_LIMIT"
          fi

          if [ "$STAGE" = "all" ]; then
            python -m osf_sync.pipeline run-all \
              --pdf-limit "$LIMIT" \
              --grobid-limit "$LIMIT" \
              --extract-limit "$LIMIT" \
              --enrich-limit "$LIMIT" \
              --download-workers "$DL_WORKERS" \
              --enrich-workers "$ENRICH_WORKERS" \
              --orcid-workers "$ORCID_WORKERS" \
              --max-seconds-per-stage 3600 \
              $EMAIL_ARGS \
              | tee /tmp/pipeline_output.json
          else
            EXTRA_ARGS=""
            STAGE_LIMIT="$LIMIT"
            if [ "$STAGE" = "email" ]; then
              STAGE_LIMIT="$EMAIL_LIMIT"
              # Spread emails: 45 min per 10 messages = 270s per message
              SPREAD=$(( STAGE_LIMIT * 270 ))
              EXTRA_ARGS="--spread-seconds $SPREAD"
            fi
            python -m osf_sync.pipeline run \
              --stage "$STAGE" \
              --limit "$STAGE_LIMIT" \
              --download-workers "$DL_WORKERS" \
              --enrich-workers "$ENRICH_WORKERS" \
              --orcid-workers "$ORCID_WORKERS" \
              --max-seconds 18000 \
              $EXTRA_ARGS \
              | tee /tmp/pipeline_output.json
          fi

          # Check if any stage was cut short by time
          if python -c "
          import json, sys
          try:
              data = json.load(open('/tmp/pipeline_output.json'))
              stages = data.get('stages', {})
              if any(s.get('stopped_due_to_time') for s in stages.values()):
                  sys.exit(0)
              # Also check if there were items processed (backlog existed)
              total = sum(s.get('processed', 0) + s.get('failed', 0) for s in stages.values())
              if total > 0:
                  sys.exit(0)
          except Exception:
              pass
          sys.exit(1)
          "; then
            echo "has_backlog=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_backlog=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Re-trigger if backlog remains
        if: steps.run.outputs.has_backlog == 'true' && (inputs.backlog_depth || '5') != '0'
        env:
          # GITHUB_TOKEN cannot trigger new workflow runs (anti-loop protection).
          # Use a PAT or GitHub App token stored as WORKFLOW_DISPATCH_TOKEN secret.
          # If the secret is not set, this step will fail gracefully.
          GH_TOKEN: ${{ secrets.WORKFLOW_DISPATCH_TOKEN }}
        run: |
          if [ -z "$GH_TOKEN" ]; then
            echo "::warning::WORKFLOW_DISPATCH_TOKEN secret not set - cannot re-trigger. Set a PAT with 'actions:write' scope."
            exit 0
          fi
          CURRENT_DEPTH="${{ inputs.backlog_depth || '5' }}"
          NEXT_DEPTH=$((CURRENT_DEPTH - 1))
          if [ "$NEXT_DEPTH" -gt 0 ]; then
            echo "Backlog detected, re-triggering with depth=$NEXT_DEPTH"
            gh workflow run pipeline.yml \
              --ref "${{ github.ref_name }}" \
              -f stage="${{ inputs.stage || 'all' }}" \
              -f limit="${{ inputs.limit || '0' }}" \
              -f email_limit="${{ inputs.email_limit || '20' }}" \
              -f download_workers="${{ inputs.download_workers || '4' }}" \
              -f enrich_workers="${{ inputs.enrich_workers || '6' }}" \
              -f orcid_workers="${{ inputs.orcid_workers || '3' }}" \
              -f backlog_depth="$NEXT_DEPTH"
          else
            echo "Backlog depth exhausted, not re-triggering"
          fi
